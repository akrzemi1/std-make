<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="607">
    <tr>
        <td width="172" align="left" valign="top">Document number:</td>
        <td width="435"><span style="background-color: #FFFF00">DXXXXR0</span></td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Date:</td>
        <td width="435">2016-01-14</td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Project:</td>
        <td width="435">ISO/IEC JTC1 SC22 WG21 Programming Language C++</td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Audience:</td>
        <td width="435">Evolution Working Group</td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Reply-to:</td>
        <td width="435">Vicente J. Botet Escriba &lt;<a href="mailto:vicente.botet@wanadoo.fr">vicente.botet@wanadoo.fr</a>&gt;</td>
    </tr>
</table>

# Default Swap 
==============

**Abstract**

Defining `swap` as comparison operators, as proposed in [N4475], for simple classes is tedious, repetitive, slightly error-prone, and easily automated. 

I propose to (implicitly) supply default versions of these two operations, if needed.  The meaning `swap` is to swap each member. 

# Table of Contents

1. [Introduction](#introduction)
2. [Motivation](#motivation)
3. [Proposal](#proposal)
4. [Design Rationale](#design-rationale)
5. [Alternative solutions](#alternative-solutions)
6. [Implementability](#implementability)
7. [Open points](#open-points)
8. [Acknowledgements](#acknowledgements)
9. [References](#references)

# Introduction

Defining `swap` as comparison operators, as proposed in [N4475], for simple classes is tedious, repetitive, slightly error-prone, and easily automated. 

I propose to (implicitly) supply default versions of these two operations, if needed.  The meaning `swap` is to swap each member. 

If the simple defaults are unsuitable for a class, a programmer can, as ever, define more suitable ones or suppress the defaults. The proposal is to add the operations as an integral part of C++ (like =), rather than as a library feature. 

The proposal follows the same approach as Default comparison as in [N4475], that is, that having default generated code for these basic operations only when needed and possible would make the language simpler. 

This paper contains no proposed wording. This is a discussion paper to determine EWG interest in the feature, and if there is interest to get direction for a follow-up paper with wording.

# Motivation

Some standard algorithms require that an argument type supply an overload for `swap`. Writing such types can be tedious (and all tedious tasks are error prone).

For example

```c++
class Foo {
  int i;
  string str;
  bool b;
  //...
  friend bool operator==(const Foo& lhs, const Foo& rhs) {
    return lhs.i == rhs.i && lhs.str == rhs.str && lhs.b == rhs.b;
  }

  friend void swap(const Foo& lhs, const Foo& rhs) {
    using std::swap;
    swap(lhs.i,rhs.i);
    swap(lhs.str, rhs.str);
    swap(lhs.b, rhs.b);
  }
};
```

If Default comparison [N4475] is adopted, the `==` operator will be not needed anymore as it could be generated by default as `=` operator is already.

# Proposal

I propose to generate default version for `swap` for simple classes when needed. If those defaults are unsuitable for a type, `=delete` them. If non-default of those operations are needed, define them (as always). If an operation is already declared, a default is not generated for it. This is exactly the way assignment and constructors work today and as comparison operators would work is [N4475] is adopted.

Note that if `==` operator is defined by the user,  `swap` nor `has_value` default generation couldn't reflect the user decisions, and so it seems reasonable to don't provide such a generation. 

The same rationale given in [N4475] applies to `swap`. 


## What is the definition of `swap`?

The standard `std::swap` algorithm works well for `Movable` types. However a compiler generated member-wise `swap` function could apply to more types, e.g. `std::array` is *Swappable* and not *Movable*, and be more efficient.

## `noexcept` expression

`swap` will be generated regardless of `noexcept` of member `swap` function, and will have automatic `noexcept` specification. 

## When it could be applied

In addition to the common restrictions defined above, the following restricts the generation of `swap`

* has that operation defined or deleted in any translation unit [Note: this requires link-time
checking], or
* has a non-static data member for which the `swap` operation doesn’t exist and cannot be generated
* has a user-defined or deleted copy or move operation or destructor.
 
The generated implementation is not considered a function so it cannot have its address taken
[Note: like the = operator=].

[For example:

```c++
class S {
  int i;
  string str;
  bool b;
  //...
};

void f(S& x, S& y)
{
    swap(x,y);
}

```
Is equivalent to

```c++
class S {
  int i;
  string str;
  bool b;
  //...
};

void f(S& x, S& y)
{
    {
        using std::swap;
        swap(x.i,y.i);
        swap(x.str,y.str);
        swap(x.b,y.b);
    }
}
```
-- end]


# Design Rationale

## Rule of 6

I may be beneficial to have proper rule of six: i.e. non of following copy constructor/assignment, move constructor/assignment, `swap`, destructor is generated if at least on of them is defined. However this would be breaking change (as we may already have classes with swap, that uses compiler generated special functions), so we stick to making `swap` depended on other five. 

## `swap(T&, T&) = default`

As copy/move constructor/assignment and destructor can be declared `=default` by the author of the class, declaring `swap` as =default, should also be possible. The major case we have in mind is when the user add some traces in the destructor.


## `noexcept` waranties

One of the benefit for a default member-wise `swap` respect to `std::swap` move-based, beside the performances, is that the former can sometimes offer a better `noexcept` guarantee. E.g., for `std::vector`, `swap` can be always guaranteed to be `noexcept`, whereas its `move` operations throw.

Even, when one of the member-wise `swap` can throw, it is worth generating the member-wise `swap`  because otherwise the `std::swap` move-based will also throw as if it has a `swap` throw it will also have a `move` that throws.


# Alternative solutions

Based on a future reflection library e.g. [N4428] or [N4451], we could define the `swap` function instead of generating it.  

# Implementability

This proposal needs some compiler magic, either by generating directly the `swap` function or by providing the reflection traits as e.g. in [N4428] or [N4451].

# Open Questions

* Do we want a default or a reflection solution?

* Quiz of generating also the `swap` member function.

# Summary

Defaulting `swap` operations is simple, removes a common annoyance. It is completely compatible. In particular, the existing facilities for defining and suppressing those operations are untouched.


# Acknowledgments

Thanks to Bjarne Strustrup for its clear identification of the types that are subject to this kind of default generation in [N4475]. Many thanks to Howard Hinnant, his comments in the ML, that allowed me to  better understand how the user customization must be used and think about adding `is_uniquely_represented` specialization was introduced. Thanks to all those that have commented the idea on the std-standard ML helping to better identify the constraints and improve the proposal in general, in particular Andrzej Krzemieński and Tomasz Kamiński 

# References

[N3746]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3746.pdf "Proposing a C++1Y Swap Operator, v2"

[N4428]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4428.pdf "Type Property Queries (rev 4)"

[N4451]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4451.pdf "Static reflection"

[N4475]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4475.pdf "Default comparisons (R2)"

[N4511]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4511.html "Adding [nothrow-]swappable traits, revision 1"

[P0017R0]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0017r0.html "Extension to aggregate initialization"


* [N3746] Proposing a C++1Y Swap Operator, v2

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3746.pdf

* [N4428] Type Property Queries (rev 4)

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4428.pdf

* [N4451] Static reflection
 
    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4451.pdf

* [N4475] Default comparisons (R2)

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4475.pdf

* [N4511] "Adding [nothrow-]swappable traits, revision 1

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4511.html 

* [P0017R0] Extension to aggregate initialization

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0017r0.html


