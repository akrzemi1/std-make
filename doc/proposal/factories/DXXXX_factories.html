<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="Vicente Botet Escriba"/><meta name="DCTERMS.issued" content="2015-05-09T11:17:04" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="Vicente Botet Escriba"/><meta name="DCTERMS.modified" content="2015-05-17T02:00:33" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><base href="."/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.Contents_20_1 { font-size:12pt; font-family:Times New Roman; writing-mode:page; margin-left:0cm; margin-right:0cm; text-indent:0cm; }
	.Contents_20_2 { font-size:12pt; font-family:Times New Roman; writing-mode:page; margin-left:0.499cm; margin-right:0cm; text-indent:0cm; }
	.Contents_20_3 { font-size:12pt; font-family:Times New Roman; writing-mode:page; margin-left:0.998cm; margin-right:0cm; text-indent:0cm; }
	.Contents_20_Heading { font-size:16pt; margin-bottom:0.212cm; margin-top:0.423cm; font-family:Arial; writing-mode:page; margin-left:0cm; margin-right:0cm; text-indent:0cm; font-weight:bold; }
	.Heading { font-size:14pt; font-family:Arial; writing-mode:page; margin-top:0.423cm; margin-bottom:0.212cm; }
	.Heading_20_1 { font-size:24pt; margin-bottom:0.212cm; margin-top:0.423cm; font-family:Times New Roman; writing-mode:page; font-weight:bold; }
	.Heading_20_2 { font-size:18pt; margin-bottom:0.212cm; margin-top:0.423cm; font-family:Times New Roman; writing-mode:page; font-weight:bold; }
	.Heading_20_3 { font-size:14pt; margin-bottom:0.212cm; margin-top:0.423cm; font-family:Times New Roman; writing-mode:page; font-weight:bold; }
	.P1 { font-size:12pt; font-family:Times New Roman; writing-mode:page; text-align:left ! important; }
	.P10 { font-size:12pt; margin-bottom:0.212cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; }
	.P11 { font-size:12pt; margin-bottom:0.212cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; }
	.P12 { font-size:12pt; margin-bottom:0.212cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; }
	.P13 { font-size:12pt; margin-bottom:0cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; }
	.P14 { font-size:12pt; margin-bottom:0cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; }
	.P15 { font-size:12pt; margin-bottom:0cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; }
	.P16 { font-size:12pt; margin-bottom:0cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; }
	.P17 { font-size:12pt; margin-left:0.499cm; margin-right:0cm; text-indent:0cm; font-family:Times New Roman; writing-mode:page; }
	.P2 { font-size:10pt; margin-bottom:0.499cm; margin-top:0cm; font-family:Courier New; writing-mode:page; }
	.P3 { font-size:10pt; margin-bottom:0cm; margin-top:0cm; font-family:Courier New; writing-mode:page; margin-left:1.251cm; margin-right:0cm; text-indent:0cm; }
	.P4 { font-size:10pt; margin-bottom:0.499cm; margin-top:0cm; font-family:Courier New; writing-mode:page; margin-left:1.251cm; margin-right:0cm; text-indent:0cm; }
	.P5 { font-size:12pt; margin-bottom:0.212cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; font-weight:bold; }
	.P6 { font-size:12pt; margin-left:0cm; margin-right:0cm; text-indent:0cm; font-family:Times New Roman; writing-mode:page; }
	.P7 { font-size:12pt; margin-bottom:0.212cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; }
	.P8 { font-size:12pt; margin-bottom:0.212cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; }
	.P9 { font-size:12pt; margin-bottom:0.212cm; margin-top:0cm; font-family:Times New Roman; writing-mode:page; }
	.Preformatted_20_Text { font-size:10pt; font-family:Courier New; writing-mode:page; margin-top:0cm; margin-bottom:0cm; }
	.Standard { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.Table_20_Contents { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.Text_20_body { font-size:12pt; font-family:Times New Roman; writing-mode:page; margin-top:0cm; margin-bottom:0.212cm; }
	.Tableau1 { width:14.968cm; }
	.Tableau1_B1 { vertical-align:middle; }
	.Tableau1_A { width:4.24cm; }
	.Tableau1_B { width:10.728cm; }
	.Bullet_20_Symbols { font-family:OpenSymbol; }
	.Emphasis { font-style:italic; }
	.Source_20_Text { font-family:Courier New; }
	.T1 { font-weight:bold; }
	<!-- ODF styles with no properties representable as CSS -->
	.Sect1 { }
	</style></head><body dir="ltr" style="max-width:21.001cm;margin-top:2cm; margin-bottom:2cm; margin-left:2cm; margin-right:2cm; "><p class="Standard"> </p><table border="0" cellspacing="0" cellpadding="0" class="Tableau1"><colgroup><col width="185"/><col width="469"/></colgroup><tr><td style="text-align:left;"><p class="P1">Document number:</p></td><td style="text-align:left;width:10.728cm; " class="Tableau1_B1"><p class="Table_20_Contents">DXXXX=yy-nnnn</p></td></tr><tr><td style="text-align:left;"><p class="P1">Date:</p></td><td style="text-align:left;width:10.728cm; " class="Tableau1_B1"><p class="Table_20_Contents">2015-05-17</p></td></tr><tr><td style="text-align:left;"><p class="P1">Project:</p></td><td style="text-align:left;width:10.728cm; " class="Tableau1_B1"><p class="Table_20_Contents">Programming Language C++, Library Evolution Working Group</p></td></tr><tr><td style="text-align:left;"><p class="P1">Reply-to:</p></td><td style="text-align:left;width:10.728cm; " class="Tableau1_B1"><p class="Table_20_Contents">Vicente J. Botet Escriba &lt;<a href="mailto:vicente.botet@wanadoo.fr">vicente.botet@wanadoo.fr</a>&gt;</p></td></tr></table><p class="Heading">C++ generic factory </p><p class="Text_20_body">Experimental generic factories library for C++17. </p><p class="Text_20_body"> </p><table border="0" cellspacing="0" cellpadding="0" class="Sect1"><colgroup/><p class="Contents_20_Heading">Contents</p><tr><td><p class="P6">Introduction        </p></td></tr><tr><td><p class="P6">Motivation and Scope        </p></td></tr><tr><td><p class="P6">Tutorial        </p></td></tr><tr><td><p class="P17">Type constructor factory        </p></td></tr><tr><td><p class="P17">Emplace factory        </p></td></tr><tr><td><p class="P17">How to define a class that wouldn't need customization?        </p></td></tr><tr><td><p class="P17">How to customize an existing class        </p></td></tr><tr><td><p class="P17">How to define a type constructor?        </p></td></tr><tr><td><p class="P17">Helper classes        </p></td></tr><tr><td><p class="P6">Design rationale        </p></td></tr><tr><td><p class="P17">Customization point        </p></td></tr><tr><td><p class="P17">Why to have default customization points?        </p></td></tr><tr><td><p class="P17">reference_wrapper&lt;T&gt; overload to deduce T&amp;         </p></td></tr><tr><td><p class="P17">Product types factories        </p></td></tr><tr><td><p class="P17">High order factory        </p></td></tr><tr><td><p class="P6">Open points        </p></td></tr><tr><td><p class="P6">Technical Specification        </p></td></tr><tr><td><p class="P17">Header &lt;experimental/functional&gt; Synopsis        </p></td></tr><tr><td><p class="P17">Template function make         </p></td></tr><tr><td><p class="P6">Example of customizations        </p></td></tr><tr><td><p class="P17">optional         </p></td></tr><tr><td><p class="P17">expected         </p></td></tr><tr><td><p class="P17">future/shared_future         </p></td></tr><tr><td><p class="P17">unique_ptr         </p></td></tr><tr><td><p class="P17">shared_ptr         </p></td></tr><tr><td><p class="P6">Implementation        </p></td></tr><tr><td><p class="P6">Acknowledgements        </p></td></tr><tr><td><p class="P6">References        </p></td></tr><tr><td><p class="P6">Appendix - Non Mandatory Helper Classes        </p></td></tr><tr><td><p class="P6">History        </p></td></tr></table><p class="Text_20_body"> </p><h1 class="Heading_20_1"><a id="a__Introduction"><span/></a>Introduction</h1><p class="Text_20_body">This paper presents a proposal for a generic factory <span class="Source_20_Text">make</span> that allows to make generic algorithms that need to create an instance of a wrapped class from its underlying types.</p><p class="Text_20_body">N4471 proposes extending template parameter deduction for functions to constructors of template classes. If this proposal is accepted, it would be clear that this proposal will lost most of its added value.</p><h1 class="Heading_20_1"><a id="a__Motivation_and_Scope"><span/></a>Motivation and Scope</h1><p class="Text_20_body">All these types, <span class="Source_20_Text">shared_ptr&lt;T&gt;</span>, <span class="Source_20_Text">unique_ptr&lt;T,D&gt;</span>, <span class="Source_20_Text">optional&lt;T&gt;</span>, <span class="Source_20_Text">expected&lt;T,E&gt;</span> and <span class="Source_20_Text">future&lt;T&gt;</span>, have in common that all of them have an underlying type `T'.</p><p class="Text_20_body">There are two kind of factories: </p><ul><li><p class="P7" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>type constructor with the underlying types as parameter<span class="odfLiEnd"/> </p><ul><li><p class="P13" style="margin-left:1.995cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span><span class="Source_20_Text">back_inserter</span> <span class="odfLiEnd"/> </p></li><li><p class="P13" style="margin-left:1.995cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span><span class="Source_20_Text">make_optional</span> <span class="odfLiEnd"/> </p></li><li><p class="P13" style="margin-left:1.995cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span><span class="Source_20_Text">make_ready_future</span> <span class="odfLiEnd"/> </p></li><li><p class="P13" style="margin-left:1.995cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span><span class="Source_20_Text">make_expected</span> <span class="odfLiEnd"/> </p></li></ul></li><li><p class="P7" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>emplace construction of the underlying type given the constructor parameters<span class="odfLiEnd"/> </p><ul><li><p class="P13" style="margin-left:1.995cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span><span class="Source_20_Text">make_shared</span> <span class="odfLiEnd"/> </p></li><li><p class="P7" style="margin-left:1.995cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span><span class="Source_20_Text">make_unique</span> <span class="odfLiEnd"/> </p></li></ul></li></ul><p class="Text_20_body">When writing an application, the user knows if the function to write should return a specific type,<br/>as <span class="Source_20_Text">shared_ptr&lt;T&gt;</span>, <span class="Source_20_Text">unique_ptr&lt;T,D&gt;</span>, <span class="Source_20_Text">optional&lt;T&gt;</span>, <span class="Source_20_Text">expected&lt;T,E&gt;</span> or <span class="Source_20_Text">future&lt;T&gt;</span>. E.g. when the user knows that the function must return a owned smart pointer it would use <span class="Source_20_Text">unique_ptr&lt;T&gt;</span>.</p><p class="P3">template &lt;class T&gt;</p><p class="P3">unique_ptr&lt;T&gt; f() {</p><p class="P3">  T a,</p><p class="P3">  ...</p><p class="P3">  return make_unique(a);</p><p class="P3">  //return unique_ptr(a); // would this be correct if N4471 is accepted?</p><p class="P4">}</p><p class="Text_20_body">If the user knows that the function must return a shared smart pointer</p><p class="P3">template &lt;class T&gt;</p><p class="P3">shared_ptr&lt;T&gt; f() {</p><p class="P3">  T a,</p><p class="P3">  ...</p><p class="P3">  return make_shared(a);</p><p class="P3">  //return shared_ptr(a); // would this be correct if N4471 is accepted?</p><p class="P4">}</p><p class="Text_20_body">However when writing a library, the author doesn't always know which type the user wants as a result. In these case the function library must take some kind of type constructor to let the user make the choice.</p><p class="P3">template &lt;template &lt;class&gt; class TC, class T&gt;</p><p class="P3">TC&lt;T&gt; f() {</p><p class="P3">  T a,</p><p class="P3">  ...</p><p class="P3">  return make&lt;TC&gt;(a);</p><p class="P3">  //return TC(a); // if N4471 is accepted</p><p class="P4">}</p><p class="Text_20_body">In addition, we have factories for the product types such as <span class="Source_20_Text">pair</span>and <span class="Source_20_Text">tuple</span></p><ul><li><p class="P14" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span><span class="Source_20_Text">make_pair</span> <span class="odfLiEnd"/> </p></li><li><p class="P8" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span><span class="Source_20_Text">make_tuple</span> <span class="odfLiEnd"/> </p></li></ul><p class="Text_20_body">We can use the class template name as a type constructor</p><p class="P3">vector&lt;int&gt; vi1 = { 0, 1, 1, 2, 3, 5, 8 };</p><p class="P3">vector&lt;int&gt; vi2;</p><p class="P3">copy_n(vi1, 3, make&lt;back_insert_iterator&gt;(vi2));</p><p class="P3"> </p><p class="P3">int v=0;</p><p class="P3">auto x1 = make&lt;shared_ptr&gt;(v);</p><p class="P3">auto x2 = make&lt;unique_ptr&gt;(v);</p><p class="P3">auto x3 = make&lt;optional&gt;(v);</p><p class="P3">auto x4 = make&lt;future&gt;(v);</p><p class="P3">auto x5 = make&lt;shared_future&gt;(v);</p><p class="P3">auto x6 = make&lt;expected&gt;(v);</p><p class="P3">auto x7 = make&lt;pair&gt;(v, v);</p><p class="P4">auto x8 = make&lt;tuple&gt;(v, v, 1u);</p><p class="Text_20_body">or making use of <span class="Source_20_Text">reference_wrapper</span> type deduction</p><p class="P3">int v=0;</p><p class="P4">future&lt;int&amp;&gt; x4 = make&lt;future&gt;(std::ref(v));</p><p class="Text_20_body">or use the class name to build to support in place construction</p><p class="P3">auto x1 = make&lt;shared_ptr&lt;A&gt;&gt;(v, v);</p><p class="P3">auto x2 = make&lt;unique_ptr&lt;A&gt;&gt;(v, v);</p><p class="P3">auto x3 = make&lt;optional&lt;A&gt;&gt;();</p><p class="P3">auto x4 = make&lt;future&lt;A&gt;&gt;(v);</p><p class="P3">auto x5 = make&lt;shared_future&lt;A&gt;&gt;(v, v);</p><p class="P4">auto x6 = make&lt;expected&lt;A&gt;&gt;(v, v);</p><p class="Text_20_body">Note, if N4471 is accepted, the following will be already possible</p><p class="P3">int v=0;</p><p class="P3">auto x3 = optional(v);</p><p class="P3">auto x7 = pair(v, v);</p><p class="P4">auto x8 = tuple(v, v, 1u);</p><p class="Text_20_body">We can also make use of the class name to avoid the type deduction</p><p class="P3">int i;</p><p class="P4">auto x1 = make&lt;future&lt;long&gt;&gt;(i);</p><p class="Text_20_body">Sometimes the user wants that the underlying type be deduced from the parameter, but the type constructor needs more information. A type holder <span class="Source_20_Text">_t</span>can be used to mean any type <span class="Source_20_Text">T</span>.</p><p class="P3">auto x2 = make&lt;expected&lt;_t, E&gt;&gt;(v);</p><p class="P4">auto x2 = make&lt;unique_ptr&lt;_t, MyDeleter&gt;&gt;(v);</p><h1 class="Heading_20_1"><a id="a__Tutorial"><span/></a>Tutorial</h1><h2 class="Heading_20_2"><a id="a__Type_constructor_factory"><span/></a>Type constructor factory</h2><p class="P3">template &lt;class TC&gt;</p><p class="P3">  apply&lt;TC, int&gt; safe_divide(int i, int j)</p><p class="P3">{</p><p class="P3">  if (j == 0)</p><p class="P3">    return none&lt;TC&gt;();</p><p class="P3">  else</p><p class="P3">    return make&lt;TC&gt;(i / j);</p><p class="P4">}</p><p class="Text_20_body">We can use this function with different type constructor as</p><p class="P4">auto x = safe_divide&lt;optional&lt;_t&gt;&gt;(1, 0);</p><p class="Text_20_body">or</p><p class="P4">auto x = safe_divide&lt;expected&lt;_t&gt;&gt;(1, 0);</p><h2 class="Heading_20_2"><a id="a__Emplace_factory"><span/></a>Emplace factory</h2><h2 class="Heading_20_2"><a id="a__How_to_define_a_class_that_wouldn't_need_customization?"><span/></a>How to define a class that wouldn't need customization?</h2><p class="Text_20_body">For the <span class="Source_20_Text">make</span> default constructor function, the class needs at least to have a default constructor</p><p class="P4">C();</p><p class="Text_20_body">For the <span class="Source_20_Text">make</span> copy/move constructor function, the class needs at least to have a constructor from the underlying types.</p><p class="P4">C(Xs&amp;&amp;...);</p><h2 class="Heading_20_2"><a id="a__How_to_customize_an_existing_class"><span/></a>How to customize an existing class</h2><p class="Text_20_body">When the existing class doesn't provide the needed constructor as e.g. <span class="Source_20_Text">future&lt;T&gt;</span>, the user needs to add the missing overloads for <span class="Source_20_Text">make_custom</span> so that they can be found by ADL.</p><p class="P3">namespace boost {</p><p class="P3">  future&lt;void&gt; make_custom(meta::type&lt;future&lt;void&gt;&gt;) </p><p class="P3">  { </p><p class="P3">    return make_ready_future(); </p><p class="P3">    }</p><p class="P3">  template &lt;class T, class ...Args&gt;</p><p class="P3">  future&lt;T&gt; make_custom(meta::type&lt;future&lt;T&gt;&gt;, Args&amp;&amp; ...args)</p><p class="P3">  { </p><p class="P3">    return make_ready_future&lt;T&gt;(forward&lt;Args&gt;(x)...); </p><p class="P3">  }</p><p class="P4">}</p><h2 class="Heading_20_2"><a id="a__How_to_define_a_type_constructor?"><span/></a>How to define a type constructor?</h2><p class="Text_20_body">The simple case is when the class has a single template parameter as is the case for <span class="Source_20_Text">future&lt;T&gt;</span>. </p><p class="P3">namespace boost</p><p class="P3">{</p><p class="P3">  struct future_tc {</p><p class="P3">    template &lt;class T&gt;</p><p class="P3">    using apply = future&lt;T&gt;;</p><p class="P3">  };</p><p class="P4">}</p><p class="Text_20_body">When the class has two parameter and the underlying type is the first template parameter, as it is the case for <span class="Source_20_Text">expected</span>, </p><p class="P3">namespace boost</p><p class="P3">{</p><p class="P3">  template &lt;class E&gt;</p><p class="P3">  struct expected_tc&lt;E&gt; {</p><p class="P3">    template &lt;class T&gt;</p><p class="P3">    using apply = expected&lt;T, E&gt;;</p><p class="P3">  };</p><p class="P4">}</p><p class="Text_20_body">If the second template depends on the first one as it is the case of <span class="Source_20_Text">unique_ptr&lt;T, D&gt;</span>, the rebind of the second parameter must be done explicitly. </p><p class="P3">namespace boost</p><p class="P3">{</p><p class="P3">  namespace detail</p><p class="P3">  {</p><p class="P3">    template &lt;class D, class T&gt;</p><p class="P3">    struct rebind;</p><p class="P3">    template &lt;template &lt;class...&gt; class TC, class ...Ts, class ...Us&gt;</p><p class="P3">    struct rebind&lt;TC&lt;Ts...&gt;, Us...&gt;&gt; {</p><p class="P3">      using type = TC&lt;Us...&gt;; </p><p class="P3">    };</p><p class="P3">    template &lt;class M, class ...Us&gt;</p><p class="P3">    using rebind_t = typename rebind&lt;M, Us...&gt;&gt;::type;</p><p class="P3">  }</p><p class="P3"> </p><p class="P3">  template &lt;&gt;</p><p class="P3">    struct default_delete&lt;experimental::_t&gt; </p><p class="P3">  {</p><p class="P3">    template&lt;class T&gt;</p><p class="P3">    using apply = default_delete&lt;T&gt;;</p><p class="P3">  };</p><p class="P3"> </p><p class="P3">  template &lt;class D&gt;</p><p class="P3">    struct unique_ptr&lt;experimental::_t, D&gt;</p><p class="P3">  {</p><p class="P3">    template&lt;class T&gt;</p><p class="P3">    using apply = unique_ptr&lt;T, detail::rebind_t&lt;D, T&gt;&gt;;</p><p class="P3">  };</p><p class="P4">}</p><h2 class="Heading_20_2"><a id="a__Helper_classes"><span/></a>Helper classes</h2><p class="Text_20_body">Defining these type constructors is cumbersome. This task can be simplified with some helper classes. </p><p class="P3">  // type holder</p><p class="P3">  struct _t {};</p><p class="P3"> </p><p class="P3">namespace meta</p><p class="P3">{</p><p class="P3">  // identity meta-function</p><p class="P3">  template&lt;class T&gt;</p><p class="P3">    struct id</p><p class="P3">    {</p><p class="P3">      using type = T;</p><p class="P3">    };</p><p class="P3"> </p><p class="P3">  // lift a class template to a type constructor</p><p class="P3">  template &lt;template &lt;class ...&gt; class TC, class... Args&gt;</p><p class="P3">    struct lift;</p><p class="P3"> </p><p class="P3">  // reverse lift a class template to a type constructor</p><p class="P3">  template &lt;template &lt;class ...&gt; class TC, class... Args&gt;</p><p class="P3">    struct reverse_lift;</p><p class="P3"> </p><p class="P3">  template &lt;class M, class ...U&gt;</p><p class="P3">  struct rebind : id&lt;typename M::template rebind&lt;U...&gt;&gt; {};</p><p class="P3"> </p><p class="P3">  template &lt;template&lt;class ...&gt; class TC, class ...Ts, class ...Us&gt;</p><p class="P3">  struct rebind&lt;TC&lt;Ts...&gt;, Us...&gt; : id&lt;TC&lt;Us...&gt;&gt; {};</p><p class="P3"> </p><p class="P3">  template &lt;class M, class ...Us&gt;</p><p class="P3">  using rebind_t = eval&lt;rebind&lt;M, Us...&gt;&gt;;</p><p class="P3"> </p><p class="P4">}</p><p class="Text_20_body">The previous type constructors could be rewritten using these helper classes as follows:</p><p class="P3">namespace boost</p><p class="P3">{</p><p class="P3">  template &lt;&gt; struct future&lt;_t&gt; : std::experimental::meta::lift&lt;future&gt; {};</p><p class="P4">}</p><p class="P3">namespace boost</p><p class="P3">{</p><p class="P3">  template &lt;class E&gt; struct expected&lt;_t, E&gt; : std::experimental::meta::reverse_lift&lt;expected, E&gt; {};</p><p class="P4">}</p><p class="P3">namespace boost</p><p class="P3">{</p><p class="P3"> </p><p class="P3">  template &lt;&gt;</p><p class="P3">    struct default_delete&lt;_t&gt; : std::experimental::meta::lift&lt;default_delete&gt; {};</p><p class="P3"> </p><p class="P3">  template &lt;class D&gt;</p><p class="P3">    struct unique_ptr&lt;_t, D&gt;</p><p class="P3">  {</p><p class="P3">    template&lt;class T&gt;</p><p class="P3">    using apply = unique_ptr&lt;T, std::experimental::meta::rebind_t&lt;D, T&gt;&gt;;</p><p class="P3">  };</p><p class="P4">}</p><h1 class="Heading_20_1"><a id="a__Design_rationale"><span/></a>Design rationale</h1><h2 class="Heading_20_2"><a id="a__Customization_point"><span/></a>Customization point</h2><p class="Text_20_body">This proposal takes advatage of overloading the <span class="Source_20_Text">make_custom</span> functions adding the tag <span class="Source_20_Text">type&lt;T&gt;</span>.</p><p class="Text_20_body">We have named the customization points <span class="Source_20_Text">make_custom</span> to make more evident that these are customization points.</p><h2 class="Heading_20_2"><a id="a__Why_to_have_default_customization_points?"><span/></a>Why to have default customization points?</h2><p class="Text_20_body">The first factoy <span class="Source_20_Text">make</span> uses default constructor to build a <span class="Source_20_Text">C&lt;void&gt;</span>. </p><p class="Text_20_body">The second factoy <span class="Source_20_Text">make</span> uses conversion constructor from the underlying type(s). </p><p class="Text_20_body">The third factory <span class="Source_20_Text">make</span> is used to be able to do emplace construction given the specific type.</p><h2 class="Heading_20_2"><a id="a__reference_wrapper_T__overload_to_deduce_T_"><span/></a><span class="Source_20_Text">reference_wrapper&lt;T&gt;</span> overload to deduce <span class="Source_20_Text">T&amp;</span> </h2><p class="Text_20_body">As it is the case for <span class="Source_20_Text">make_pair</span> when the parameter is <span class="Source_20_Text">reference_wrapper&lt;T&gt;</span>, the type deduced for the underlying type is <span class="Source_20_Text">T&amp;</span>.</p><h2 class="Heading_20_2"><a id="a__Product_types_factories"><span/></a>Product types factories</h2><p class="Text_20_body">This proposal takes into account also product type factories (as <span class="Source_20_Text">std::pair</span> or <span class="Source_20_Text">std::tuple</span>). </p><p class="P3">// make product factory overload: Deduce the resulting `Us` </p><p class="P3">template &lt;template &lt;class...&gt; class T, class ...Ts&gt;</p><p class="P3">  T&lt;Us...&gt; make(Ts&amp;&amp; ...args);</p><p class="P3">// make product factory overload: Deduce the resulting `Us` </p><p class="P3">template &lt;class TC, class ...Ts&gt;</p><p class="P4">  apply&lt;TC, Us...&gt; make(Ts&amp;&amp; ...args);</p><p class="P3">auto x = make&lt;pair&gt;(1, 2u);  </p><p class="P4">auto x = make&lt;tuple&gt;(1, 2u, string("a");  </p><h2 class="Heading_20_2"><a id="a__High_order_factory"><span/></a>High order factory</h2><p class="Text_20_body">It is simple to define a high order <span class="Source_20_Text">maker&lt;TC&gt;</span> factory of factories that can be used in standard algorithms. </p><p class="Text_20_body">For example</p><p class="P3">std::vector&lt;X&gt; xs;</p><p class="P3">std::vector&lt;Something&lt;X&gt;&gt; ys;</p><p class="P4">std::transform(xs.begin(), xs.end(), std::back_inserter(ys), maker&lt;Something&gt;{});</p><p class="P3">template &lt;template &lt;class&gt; class T&gt;</p><p class="P3">  struct maker {</p><p class="P3">    template &lt;typename ...X&gt;</p><p class="P3">    constexpr auto</p><p class="P3">    operator()(X&amp;&amp; ...x) const</p><p class="P3">    {</p><p class="P3">        return make&lt;T&gt;(forward&lt;X&gt;(x)...);</p><p class="P3">    }     </p><p class="P4">};</p><p class="Text_20_body">The main problem defining function objects is that we can not have the same class with different template parameters. The <span class="Source_20_Text">maker</span> class template has a template class parameter. We need an additional classes that takes a meta-function class and a type.</p><p class="Preformatted_20_Text">template &lt;template &lt;class&gt; class T&gt;</p><p class="Preformatted_20_Text">  struct maker_tc {</p><p class="Preformatted_20_Text">    template &lt;typename ...X&gt;</p><p class="Preformatted_20_Text">    constexpr auto</p><p class="Preformatted_20_Text">    operator()(X&amp;&amp; ...x) const</p><p class="Preformatted_20_Text">    {</p><p class="Preformatted_20_Text">        return make&lt;T&gt;(forward&lt;X&gt;(x)...);</p><p class="Preformatted_20_Text">    }     </p><p class="Preformatted_20_Text">  };</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">template &lt;class MFC&gt; // requires MFC is a type constructor</p><p class="Preformatted_20_Text">  struct maker_mfc {</p><p class="Preformatted_20_Text">    template &lt;class ...Xs&gt;</p><p class="Preformatted_20_Text">    constexpr auto</p><p class="Preformatted_20_Text">    operator()(Xs&amp;&amp; ...xs)</p><p class="Preformatted_20_Text">    {</p><p class="Preformatted_20_Text">      return make&lt;MFC&gt;(std::forward&lt;Xs&gt;(xs)...);</p><p class="Preformatted_20_Text">    }</p><p class="Preformatted_20_Text">  };</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">template &lt;class M&gt; // requires M is a type</p><p class="Preformatted_20_Text">  struct maker_t</p><p class="Preformatted_20_Text">  {</p><p class="Preformatted_20_Text">    template &lt;class ...Args&gt;</p><p class="Preformatted_20_Text">    constexpr M operator()(Args&amp;&amp; ...args) const</p><p class="Preformatted_20_Text">    {</p><p class="Preformatted_20_Text">      return make&lt;M&gt;(std::forward&lt;Args&gt;(args)...);</p><p class="Preformatted_20_Text">    }</p><p class="P2">  };</p><h1 class="Heading_20_1"><a id="a__Open_points"><span/></a>Open points</h1><p class="Text_20_body">The authors would like to have an answer to the following points if there is at all an interest in this proposal:</p><p class="P5">Is there an interest on the make functions?</p><p class="P5">Is there an interest on the none functions?</p><p class="P5">Should the customization be done with overloading or with traits?</p><p class="Text_20_body">The current proposal uses overloading as customization point. The alternative is to use traits as e.g. the library Hana uses.</p><p class="Text_20_body">If overloading is preferred, </p><ul><li><p class="P9" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>should the customization function names be suffixed e.g. with <span class="Source_20_Text">_custom</span>?<span class="odfLiEnd"/> </p></li><li><p class="P9" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>As <span class="Source_20_Text">id</span> and <span class="Source_20_Text">type</span> do the same, should the <span class="Source_20_Text">type</span> be replaced by <span class="Source_20_Text">id</span> or the oposite?<span class="odfLiEnd"/> </p></li></ul><p class="Text_20_body"><span class="T1">Should the namespace </span><span class="Source_20_Text"><span class="T1">meta</span></span><span class="T1"> be used for the meta programming utilities </span><span class="Source_20_Text"><span class="T1">apply</span></span><span class="T1"> and </span><span class="Source_20_Text"><span class="T1">type</span></span><span class="T1">?</span></p><p class="P5">Should the function object factories be part of the proposal?</p><p class="Text_20_body">The function objects <span class="Source_20_Text">maker_tc</span>, <span class="Source_20_Text">maker_mfc</span> and <span class="Source_20_Text">maker_t</span> could be quite useful. </p><p class="Text_20_body">What should be the default for <span class="Source_20_Text">maker</span>? </p><p class="Text_20_body"><span class="T1">Should the function factories </span><span class="Source_20_Text"><span class="T1">make</span></span><span class="T1"> and </span><span class="Source_20_Text"><span class="T1">none</span></span><span class="T1"> be function objects?</span></p><p class="Text_20_body">N4381 proposes to use function objects as customized points, so that ADL is not involved.</p><p class="Text_20_body">This has the advantages to solve the function ans the high order function at once.</p><p class="Text_20_body">The same technique is used a lot in other functional libraries as Range, Fit and Pure. </p><p class="Text_20_body"><span class="T1">Is there an interest on the helper holder </span><span class="Source_20_Text"><span class="T1">_t</span></span><span class="T1">?</span></p><p class="Text_20_body">While not need absolutely, it helps to define the type constructors.</p><p class="Text_20_body"><span class="T1">Is there an interest on the helper meta-functions </span><span class="Source_20_Text"><span class="T1">id</span></span><span class="T1">, </span><span class="Source_20_Text"><span class="T1">types</span></span><span class="T1">, </span><span class="Source_20_Text"><span class="T1">lift</span></span><span class="T1">, </span><span class="Source_20_Text"><span class="T1">lift_reverse</span></span><span class="T1"> and </span><span class="Source_20_Text"><span class="T1">rebind</span></span><span class="T1">?</span></p><p class="Text_20_body">If yes, should them be part of a separated proposal?</p><p class="Text_20_body">There is much more on meta-programming utilities as show on the Meta library.</p><p class="Text_20_body"><span class="T1">Should the customization of the standard classes </span><span class="Source_20_Text"><span class="T1">pair</span></span><span class="T1">, </span><span class="Source_20_Text"><span class="T1">tuple</span></span><span class="T1">, </span><span class="Source_20_Text"><span class="T1">optional</span></span><span class="T1">, </span><span class="Source_20_Text"><span class="T1">future</span></span><span class="T1">, </span><span class="Source_20_Text"><span class="T1">unique_ptr</span></span><span class="T1">, </span><span class="Source_20_Text"><span class="T1">shared_ptr</span></span><span class="T1"> be part of this proposal?</span></p><h1 class="Heading_20_1"><a id="a__Technical_Specification"><span/></a>Technical Specification</h1><h2 class="Heading_20_2"><a id="a__Header__experimental_functional__Synopsis"><span/></a>Header &lt;experimental/functional&gt; Synopsis</h2><p class="Text_20_body">Add the following declaration in experimental/functional.</p><p class="Preformatted_20_Text">namespace std</p><p class="Preformatted_20_Text">{</p><p class="Preformatted_20_Text">namespace experimental</p><p class="Preformatted_20_Text">{</p><p class="Preformatted_20_Text">inline namespace fundamental_v2</p><p class="Preformatted_20_Text">{</p><p class="Preformatted_20_Text">namespace meta</p><p class="Preformatted_20_Text">{</p><p class="Preformatted_20_Text">  // apply a type constructor TC to the type parameters Args</p><p class="Preformatted_20_Text">  template &lt;class TC, class... Args&gt;</p><p class="Preformatted_20_Text">    using apply = typename TC::template apply&lt;Args...&gt;;</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // tag type</p><p class="Preformatted_20_Text">  template &lt;class T&gt;</p><p class="Preformatted_20_Text">    struct type {};</p><p class="Preformatted_20_Text">}</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  template &lt;template &lt;class ...&gt; class TC&gt;</p><p class="Preformatted_20_Text">  constexpr auto none();</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  template &lt;class TC&gt;</p><p class="Preformatted_20_Text">  constexpr auto none();</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // make() overload</p><p class="Preformatted_20_Text">  template &lt;template &lt;class ...&gt; class M&gt;</p><p class="Preformatted_20_Text">    M&lt;void&gt; make();</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  template &lt;class TC&gt;</p><p class="Preformatted_20_Text">    meta::apply&lt;TC, void&gt; make();</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // make overload: requires a template class parameter, deduce the underlying type</p><p class="Preformatted_20_Text">  template &lt;template &lt;class ...&gt; class M, class X&gt;</p><p class="Preformatted_20_Text">    M&lt;Y&gt; make(X&amp;&amp; x);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">    // make overload: requires a type constructor, deduce the underlying type</p><p class="Preformatted_20_Text">  template &lt;class TC, class X&gt;</p><p class="Preformatted_20_Text">    meta::apply&lt;TC, Y&gt; make(X&amp;&amp; x);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // make overload: requires a type with a specific underlying type, </p><p class="Preformatted_20_Text">  // don't deduce the underlying type from X</p><p class="Preformatted_20_Text">  template &lt;class M, class X&gt;</p><p class="Preformatted_20_Text">    M make(X&amp;&amp; x);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // make emplace overload: requires a type with a specific underlying type, </p><p class="Preformatted_20_Text">  // don't deduce the underlying type from Args</p><p class="Preformatted_20_Text">  template &lt;class M, class ...Args&gt;</p><p class="Preformatted_20_Text">    M make(Args&amp;&amp; ...args);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">namespace meta</p><p class="Preformatted_20_Text">{</p><p class="Preformatted_20_Text">  // default customization point for TC&lt;void&gt; default constructor</p><p class="Preformatted_20_Text">  template &lt;class M&gt;</p><p class="Preformatted_20_Text">    M make_custom(meta::type&lt;M&gt;);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // default customization point for constructor from Xs</p><p class="Preformatted_20_Text">  template &lt;class M, class ...Xs&gt;</p><p class="Preformatted_20_Text">    M make_custom(meta::type&lt;M&gt;, Xs&amp;&amp; xs);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">}  </p><p class="Preformatted_20_Text">}</p><p class="Preformatted_20_Text">}</p><p class="P2">}</p><h2 class="Heading_20_2"><a id="a__Template_function_make"><span/></a>Template function <span class="Source_20_Text">make</span> </h2><h3 class="Heading_20_3"><a id="a__template___void"><span/></a>template + void</h3><p class="Preformatted_20_Text">  template &lt;template &lt;class ...&gt; class M&gt;</p><p class="P2">  M&lt;void&gt; make();</p><p class="Text_20_body"><span class="Emphasis">Effects:</span> Forwards to the customization point <span class="Source_20_Text">make</span> with a template constructor <span class="Source_20_Text">type&lt;M&lt;void&gt;&gt;</span>. As if</p><p class="P2">    return make(meta::type&lt;M&lt;void&gt;&gt;{});</p><h3 class="Heading_20_3"><a id="a__template___deduced_underlying_type"><span/></a>template + deduced underlying type</h3><p class="Preformatted_20_Text">template &lt;template &lt;class ...&gt; class M, class T&gt;</p><p class="P2">  M&lt;V&gt; make(T&amp;&amp; x);</p><p class="Text_20_body">where <span class="Source_20_Text">V</span> is determined as follows: Let <span class="Source_20_Text">U</span> be <span class="Source_20_Text">decay_t&lt;T&gt;</span>. Then <span class="Source_20_Text">V</span> is <span class="Source_20_Text">X&amp;</span> if <span class="Source_20_Text">U</span> equals <span class="Source_20_Text">reference_wrapper&lt;X&gt;</span>, otherwise <span class="Source_20_Text">V</span> is <span class="Source_20_Text">U</span>.</p><p class="Text_20_body"><span class="Emphasis">Effects:</span> Forwards to the customization point <span class="Source_20_Text">make</span> with a template constructor <span class="Source_20_Text">meta::type&lt;M&lt;V&gt;&gt;</span>. As if</p><p class="P2">    return make(meta::type&lt;M&lt;V&gt;&gt;{}, std::forward&lt;T&gt;(x));</p><h3 class="Heading_20_3"><a id="a__type_constructor___deduced_underlying_type"><span/></a>type constructor + deduced underlying type</h3><p class="Preformatted_20_Text">  template &lt;class TC, class T&gt;</p><p class="P2">    meta::apply&lt;TC, V&gt; make(T&amp;&amp; x);</p><p class="Text_20_body">where <span class="Source_20_Text">V</span> is determined as follows: Let <span class="Source_20_Text">U</span> be <span class="Source_20_Text">decay_t&lt;T&gt;</span>. Then <span class="Source_20_Text">V</span> is <span class="Source_20_Text">X&amp;</span> if <span class="Source_20_Text">U</span> equals <span class="Source_20_Text">reference_wrapper&lt;X&gt;</span>, otherwise <span class="Source_20_Text">V</span> is <span class="Source_20_Text">U</span>.</p><p class="Text_20_body"><span class="Emphasis">Requires:</span> <span class="Source_20_Text">TC</span> is a type constructor.</p><p class="Text_20_body"><span class="Emphasis">Effects:</span> Forwards to the customization point <span class="Source_20_Text">make</span> with a template constructor <span class="Source_20_Text">meta::type&lt;meta::apply&lt;TC, V&gt;&gt;</span>. As if</p><p class="P2">    return make(meta::type&lt;meta::apply&lt;TC, V&gt;&gt;{}, std::forward&lt;T&gt;(x));</p><h3 class="Heading_20_3"><a id="a__type___non_deduced_underlying_type"><span/></a>type + non deduced underlying type</h3><p class="Preformatted_20_Text">template &lt;class M, class X&gt;</p><p class="P2">  M make(X&amp;&amp; x);</p><p class="Text_20_body"><span class="Emphasis">Requires:</span> <span class="Source_20_Text">M</span> is not a type constructor and the underlying type of <span class="Source_20_Text">M</span> is convertible from <span class="Source_20_Text">X</span>.</p><p class="Text_20_body"><span class="Emphasis">Effects:</span> Forwards to the customization point <span class="Source_20_Text">make</span> with a template constructor <span class="Source_20_Text">meta::type&lt;M&gt;</span>. As if</p><p class="P2">    return meta::make(meta::type&lt;M&gt;{}, std::forward&lt;X&gt;(x));</p><h3 class="Heading_20_3"><a id="a__type___emplace_args"><span/></a>type + emplace args</h3><p class="Preformatted_20_Text">template &lt;class M, class ...Args&gt;</p><p class="P2">  M make(Args&amp;&amp; ...args);</p><p class="Text_20_body"><span class="Emphasis">Effects:</span> Forwards to the customization point <span class="Source_20_Text">make</span> with a type constructor <span class="Source_20_Text">meta::type&lt;M&gt;</span> and <span class="Source_20_Text">in_place_t</span>. As if</p><p class="P2">    return make(meta::type&lt;M&gt;{}, std::forward&lt;Args&gt;(args)...);</p><h3 class="Heading_20_3"><a id="a__Template_function_make_custom_-_default_constructor_customization_point_for_void"><span/></a>Template function <span class="Source_20_Text">make_custom</span> - default constructor customization point for void</h3><p class="Preformatted_20_Text">  template &lt;class M&gt;</p><p class="P2">  M make_custom(meta::type&lt;M&gt;)</p><p class="Text_20_body"><span class="Emphasis">Returns:</span> A <span class="Source_20_Text">M</span> constructed using the constructor <span class="Source_20_Text">M()</span></p><p class="Text_20_body"><span class="Emphasis">Throws:</span> Any exception thrown by the constructor.</p><h3 class="Heading_20_3"><a id="a__copy_constructor_customization_point"><span/></a>copy constructor customization point</h3><p class="Preformatted_20_Text">template &lt;class M, class ...Xs&gt;</p><p class="P2">  M make_custom(meta::type&lt;M&gt;, Xs&amp;&amp; xs);</p><p class="Text_20_body"><span class="Emphasis">Returns:</span> A <span class="Source_20_Text">M</span> constructed using the constructor <span class="Source_20_Text">M(std::forward&lt;Xs&gt;(xs)...)</span></p><p class="Text_20_body"><span class="Emphasis">Throws:</span> Any exception thrown by the constructor.</p><h1 class="Heading_20_1"><a id="a__Example_of_customizations"><span/></a>Example of customizations</h1><p class="Text_20_body">Next follows some examples of customizations that could be included in the standard</p><h2 class="Heading_20_2"><a id="a__optional"><span/></a><span class="Source_20_Text">optional</span> </h2><p class="Preformatted_20_Text">namespace std {</p><p class="Preformatted_20_Text">namespace experimental {</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // Holder specialization</p><p class="Preformatted_20_Text">  template &lt;&gt;</p><p class="Preformatted_20_Text">  struct optional&lt;_t&gt;;</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">}</p><p class="P2">}</p><h2 class="Heading_20_2"><a id="a__expected"><span/></a><span class="Source_20_Text">expected</span> </h2><p class="Preformatted_20_Text">namespace std {</p><p class="Preformatted_20_Text">namespace experimental {</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // Holder specialization</p><p class="Preformatted_20_Text">  template &lt;class E&gt;</p><p class="Preformatted_20_Text">  struct expected&lt;_t, E&gt;;</p><p class="Preformatted_20_Text">}</p><p class="P2">}</p><h2 class="Heading_20_2"><a id="a__future_shared_future"><span/></a><span class="Source_20_Text">future</span>/<span class="Source_20_Text">shared_future</span> </h2><p class="Preformatted_20_Text">namespace std {</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // customization point for template </p><p class="Preformatted_20_Text">  // (needed because std::experimental::future doesn't has a default constructor)</p><p class="Preformatted_20_Text">  future&lt;void&gt; make_custom(experimental::meta::type&lt;future&lt;void&gt;&gt;);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // customization point for template</p><p class="Preformatted_20_Text">  // (needed because std::experimental::future doesn't has a conversion constructor)</p><p class="Preformatted_20_Text">  template &lt;class DX, class X&gt;</p><p class="Preformatted_20_Text">    future&lt;DX&gt; make_custom(experimental::meta::type&lt;future&lt;DX&gt;&gt;, X&amp;&amp; x);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // customization point for template </p><p class="Preformatted_20_Text">  // (needed because std::experimental::future doesn't uses experimental::in_place_t)</p><p class="Preformatted_20_Text">  template &lt;class X, class ...Args&gt;</p><p class="Preformatted_20_Text">    future&lt;X&gt; make_custom(experimental::meta::type&lt;future&lt;X&gt;&gt;, experimental::in_place_t, Args&amp;&amp; ...args);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // customization point for template </p><p class="Preformatted_20_Text">  // (needed because std::experimental::shared_future doesn't has a default constructor)</p><p class="Preformatted_20_Text">  shared_future&lt;void&gt; make_custom(experimental::meta::type&lt;shared_future&lt;void&gt;&gt;);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // customization point for template </p><p class="Preformatted_20_Text">  // (needed because std::experimental::shared_future&lt;X&gt; doesn't has a constructor from X)</p><p class="Preformatted_20_Text">  template &lt;class DX, class X&gt;</p><p class="Preformatted_20_Text">    shared_future&lt;DX&gt; make_custom(experimental::meta::type&lt;shared_future&lt;DX&gt;&gt;, X&amp;&amp; x);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // customization point for template </p><p class="Preformatted_20_Text">  // (needed because std::experimental::shared_future doesn't use experimental::in_place_t)</p><p class="Preformatted_20_Text">  template &lt;class X, class ...Args&gt;</p><p class="Preformatted_20_Text">    shared_future&lt;X&gt; make_custom(experimental::meta::type&lt;shared_future&lt;X&gt;&gt;, experimental::in_place_t, Args&amp;&amp; ...args);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // Holder specializations</p><p class="Preformatted_20_Text">  template &lt;&gt;</p><p class="Preformatted_20_Text">    struct future&lt;experimental::_t&gt;;</p><p class="Preformatted_20_Text">  template &lt;&gt;</p><p class="Preformatted_20_Text">    struct future&lt;experimental::_t&amp;&gt;;</p><p class="Preformatted_20_Text">  template &lt;&gt;</p><p class="Preformatted_20_Text">    struct shared_future&lt;experimental::_t&gt;;</p><p class="Preformatted_20_Text">  template &lt;&gt;</p><p class="Preformatted_20_Text">    struct shared_future&lt;experimental::_t&amp;&gt;;   </p><p class="P2">}</p><h2 class="Heading_20_2"><a id="a__unique_ptr"><span/></a><span class="Source_20_Text">unique_ptr</span> </h2><p class="Preformatted_20_Text">namespace std {</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // customization point for template </p><p class="Preformatted_20_Text">  // (needed because std::unique_ptr doesn't has a conversion constructor)</p><p class="Preformatted_20_Text">  template &lt;class DX, class ...Xs&gt;</p><p class="Preformatted_20_Text">    unique_ptr&lt;DX&gt; make_custom(experimental::meta::type&lt;unique_ptr&lt;DX&gt;&gt;, Xs&amp;&amp; xs);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // Holder customization</p><p class="Preformatted_20_Text">  template &lt;class D&gt;</p><p class="Preformatted_20_Text">  struct unique_ptr&lt;experimental::_t, D&gt;;</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  template &lt;&gt;</p><p class="Preformatted_20_Text">  struct default_delete&lt;experimental::_t&gt;;</p><p class="Preformatted_20_Text"> </p><p class="P2">}</p><h2 class="Heading_20_2"><a id="a__shared_ptr"><span/></a><span class="Source_20_Text">shared_ptr</span> </h2><p class="Preformatted_20_Text">namespace std {</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // customization point for template </p><p class="Preformatted_20_Text">  // (needed because std::shared_ptr doesn't has a conversion constructor)</p><p class="Preformatted_20_Text">  template &lt;class DX, class ...Xs&gt;</p><p class="Preformatted_20_Text">  shared_ptr&lt;DX&gt; make_custom(experimental::meta::type&lt;shared_ptr&lt;DX&gt;&gt;, Xs&amp;&amp; xs);</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // Holder customization</p><p class="Preformatted_20_Text">  template &lt;&gt;</p><p class="Preformatted_20_Text">  struct shared_ptr&lt;experimental::_t&gt;;</p><p class="Preformatted_20_Text"> </p><p class="P2">}</p><h1 class="Heading_20_1"><a id="a__Implementation"><span/></a>Implementation</h1><p class="Text_20_body">There is an implementation at <a href="https://github.com/viboes/std-make">https://github.com/viboes/std-make</a>.</p><h1 class="Heading_20_1"><a id="a__Acknowledgements"><span/></a>Acknowledgements</h1><p class="Text_20_body">Many thanks to Agustín K-ballo Bergé from which I learn the trick to implement the different overloads. Scott Pager helped me to identify a minimal proposal, making optional the helper classes and of course the addition high order functional factory and the missing reference_wrapper overload.</p><p class="Text_20_body">Thanks to Mike Spertus for its N4471 proposal that would even help to avoid the factories in the common cases. </p><h1 class="Heading_20_1"><a id="a__References"><span/></a>References</h1><ul><li><p class="P10" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>N4471 - Template parameter deduction for constructors (Rev. 2) <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4471.html">http://open-</a><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4471.html">std.org/JTC1/SC22/WG21/docs/papers/2015/n4471.html</a><span class="odfLiEnd"/> </p></li><li><p class="P10" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>N4381 - Suggested Design for Customization Points <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4381.html">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4381.html</a><span class="odfLiEnd"/> </p></li><li><p class="P10" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>N4480 - Programming Languages — C++ Extensions for Library Fundamentals <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4480.html">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4480.html</a><span class="odfLiEnd"/> </p></li><li><p class="P10" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>N4015 - A proposal to add a utility class to represent expected monad <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4015.pdf">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4015.pdf</a><span class="odfLiEnd"/> </p></li><li><p class="P10" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Range-V3 <a href="https://github.com/ericniebler/range-v3">https://github.com/ericniebler/range-v3</a><span class="odfLiEnd"/> </p></li><li><p class="P10" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Meta <a href="https://github.com/ericniebler/meta">https://github.com/ericniebler/meta</a><span class="odfLiEnd"/> </p></li><li><p class="P10" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Hana <a href="https://github.com/ldionne/hana">https://github.com/ldionne/hana</a><span class="odfLiEnd"/> </p></li><li><p class="P10" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Pure <a href="https://github.com/splinterofchaos/Pure">https://github.com/splinterofchaos/Pure</a><span class="odfLiEnd"/> </p></li><li><p class="P10" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Fit <a href="https://github.com/pfultz2/Fit">https://github.com/pfultz2/Fit</a><span class="odfLiEnd"/> </p></li></ul><h1 class="Heading_20_1"><a id="a__Appendix_-_Non_Mandatory_Helper_Classes"><span/></a>Appendix - Non Mandatory Helper Classes</h1><p class="Text_20_body">In the original proposal there were some helper classes as <span class="Source_20_Text">lift</span>, <span class="Source_20_Text">reverse_lift</span>, <span class="Source_20_Text">_t</span> and <span class="Source_20_Text">id</span> that are not mandatory for this proposal. If the committee has interest, a specific proposal can be written. </p><p class="Preformatted_20_Text">namespace std</p><p class="Preformatted_20_Text">{</p><p class="Preformatted_20_Text">namespace experimental</p><p class="Preformatted_20_Text">{</p><p class="Preformatted_20_Text">inline namespace fundamental_v2</p><p class="Preformatted_20_Text">{</p><p class="Preformatted_20_Text">  // type holder</p><p class="Preformatted_20_Text">  struct _t {};</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">namespace meta</p><p class="Preformatted_20_Text">{</p><p class="Preformatted_20_Text">  // identity meta-function</p><p class="Preformatted_20_Text">  template&lt;class T&gt;</p><p class="Preformatted_20_Text">    struct id</p><p class="Preformatted_20_Text">    {</p><p class="Preformatted_20_Text">      using type = T;</p><p class="Preformatted_20_Text">    };</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // lift a class template to a type constructor</p><p class="Preformatted_20_Text">  template &lt;template &lt;class ...&gt; class TC, class... Args&gt;</p><p class="Preformatted_20_Text">    struct lift;</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  // reverse lift a class template to a type constructor</p><p class="Preformatted_20_Text">  template &lt;template &lt;class ...&gt; class TC, class... Args&gt;</p><p class="Preformatted_20_Text">    struct reverse_lift;</p><p class="Preformatted_20_Text"/><p class="Preformatted_20_Text">  template &lt;class M, class ...U&gt;</p><p class="Preformatted_20_Text">  struct rebind : id&lt;typename M::template rebind&lt;U...&gt;&gt; {};</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  template &lt;template&lt;class ...&gt; class TC, class ...Ts, class ...Us&gt;</p><p class="Preformatted_20_Text">  struct rebind&lt;TC&lt;Ts...&gt;, Us...&gt; : id&lt;TC&lt;Us...&gt;&gt; {};</p><p class="Preformatted_20_Text"> </p><p class="Preformatted_20_Text">  template &lt;class M, class ...Us&gt;</p><p class="Preformatted_20_Text">  using rebind_t = typename rebind&lt;M, Us...&gt;::type;</p><p class="Preformatted_20_Text"> </p><p class="P2">}}}}</p><h1 class="Heading_20_1"><a id="a__History"><span/></a>History</h1><p class="P5">v0.1 Creation</p><p class="P5">v0.2 Take in account comments from the ML</p><ul><li><p class="P15" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Moved <span class="Source_20_Text">apply</span> and <span class="Source_20_Text">type</span> to <span class="Source_20_Text">meta</span> namespace. <span class="odfLiEnd"/> </p></li><li><p class="P15" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Added <span class="Source_20_Text">constexpr</span>. <span class="odfLiEnd"/> </p></li><li><p class="P15" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Added product type factory overload <span class="Source_20_Text">make</span> to support <span class="Source_20_Text">pair/tuple</span> types. <span class="odfLiEnd"/> </p></li><li><p class="P15" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Fix the signature of <span class="Source_20_Text">make</span> to support <span class="Source_20_Text">reference_wrapper</span> types. <span class="odfLiEnd"/> </p></li><li><p class="P15" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Added factory function object <span class="Source_20_Text">maker</span>. <span class="odfLiEnd"/> </p></li><li><p class="P15" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Added <span class="Source_20_Text">none</span> factory. <span class="odfLiEnd"/> </p></li><li><p class="P15" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Removed the emplace <span class="Source_20_Text">make</span> factory specialization. <span class="odfLiEnd"/> </p></li><li><p class="P15" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Remove <span class="Source_20_Text">type_constructor</span> as out of the scope of the proposal. It was used by <span class="Source_20_Text">unique_ptr&lt;_t, D&gt;</span> specialization, but this can be seen as an implementation detail. <span class="odfLiEnd"/> </p></li><li><p class="P15" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Remove <span class="Source_20_Text">type_constructor_tag</span> as this was an implementation detail. <span class="odfLiEnd"/> </p></li><li><p class="P15" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Refactored <span class="Source_20_Text">rebind</span>. <span class="odfLiEnd"/> </p></li><li><p class="P11" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Moved <span class="Source_20_Text">rebind</span>, <span class="Source_20_Text">lift</span>, <span class="Source_20_Text">reverse_lift</span>, <span class="Source_20_Text">_t</span> and <span class="Source_20_Text">id</span> to appendix Non Mandatory Helper Classes and to to <span class="Source_20_Text">meta</span> namespace. <span class="odfLiEnd"/> </p></li></ul><p class="P5">v0.3 Take in account comments from the ML</p><ul><li><p class="P16" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Fix some product type and emplace factories issues. <span class="odfLiEnd"/> </p></li><li><p class="P16" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Rename customization point <span class="Source_20_Text">make</span> to <span class="Source_20_Text">make_custom</span>. <span class="odfLiEnd"/> </p></li><li><p class="P12" style="margin-left:0.748cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.499cm">•.</span>Reference N4471 as this proposal would simplify most of this proposal. <span class="odfLiEnd"/> </p></li></ul><p class="Standard"> </p></body></html>